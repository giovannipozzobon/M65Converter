;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; NOTE1: This file is implemented as "semi-reusable" RRB sprites library, some of the data is hard coded to simplify implementation - ideally we'd read all this data from lookup files generated by M65Converter. But for the purposes of the companion example code, this will suffice...
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; NOTE2: I opted to use quad mode (Q = AXYZ) for positions and velocities. This requires more CPU cycles and memory, but makes the code simpler, which was the main factor for my decision.
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; for the purposes of this example sprite size is hard coded
SPRITE_WIDTH_BYTES = 4
SPRITE_HEIGHT_CHARS = 4
SPRITE_FRAME_SIZE = SPRITE_WIDTH_BYTES * (SPRITE_HEIGHT_CHARS + 2)	; each frame rows are preceeded and followed by a row of transparent chars

; again, hard coded limits on how many sprites we want to use (don't change data length since that)
SPRITE_COUNT = 2			; number of sprites

;===============================================================================
; SPRITE SELECTION
;===============================================================================

;-------------------------------------------------------------------------------
; Selects the given sprite for subsequent operations.
;
; This is quite CPU intensive routine since it sets up ZP data for ALL variables and pointers, regardless of what is actually needed. It's good enough for this demonstration, but could (should?) be improved for use in a real game.
;
; Y = sprite index
SpriteSelect:
	; save sprite index so we can retrieve it later
	sty SPRITE_INDEX

	; save position and velocity
	+ZPAssignDWordIndex _SpritePositionX, SPRITE_POSITION_X
	+ZPAssignDWordIndex _SpritePositionY, SPRITE_POSITION_Y
	+ZPAssignDWordIndex _SpriteVelocityX, SPRITE_VELOCITY_X
	+ZPAssignDWordIndex _SpriteVelocityY, SPRITE_VELOCITY_Y

	; save GOTOX screen lookup table for low byte
	lda _SpriteGotoXLoL, y
	sta SPRITE_GOTOX_LO
	lda _SpriteGotoXLoH, y
	sta SPRITE_GOTOX_LO + 1

	; save GOTOX screen lookup table for mid byte
	lda _SpriteGotoXMidL, y
	sta SPRITE_GOTOX_MID
	lda _SpriteGotoXMidH, y
	sta SPRITE_GOTOX_MID + 1

	; save GOTOX screen lookup table for high byte
	lda _SpriteGotoXHighL, y
	sta SPRITE_GOTOX_HIGH
	lda _SpriteGotoXHighH, y
	sta SPRITE_GOTOX_HIGH + 1

	; save frame data address
	lda _SpriteFramesDataL, y
	sta SPRITE_FRAME_DATA_FIRST
	lda _SpriteFramesDataH, y
	sta SPRITE_FRAME_DATA_FIRST + 1

	; save current frame data address
	lda _SpriteFramesDataCurrentL, y
	sta SPRITE_FRAME_DATA
	lda _SpriteFramesDataCurrentH, y
	sta SPRITE_FRAME_DATA + 1

	rts

;===============================================================================
; ONE TIME SETUP
;===============================================================================

;-------------------------------------------------------------------------------
; Sets up address of GOTOX lookup table for low byte.
;
; The table is expected to be 25 chars long, each char represents low byte of the address of GOTOX screen data for this sprite.
;
; X = table address high byte
; A = table address low byte
SpriteSetupGotoXLo:
	; since this routine may be called after destroying Y register, we need to always restore it
	ldy SPRITE_INDEX
	stx _SpriteGotoXLoH, y
	sta _SpriteGotoXLoL, y
	rts

;-------------------------------------------------------------------------------
; Sets up address of GOTOX lookup table for mid byte.
;
; The table is expected to be 25 chars long, each char represents low byte of the address of GOTOX screen data for this sprite.
;
; X = table address high byte
; A = table address low byte
SpriteSetupGotoXMid:
	; since this routine may be called after destroying Y register, we need to always restore it
	ldy SPRITE_INDEX
	stx _SpriteGotoXMidH, y
	sta _SpriteGotoXMidL, y
	rts

;-------------------------------------------------------------------------------
; Sets up address of GOTOX lookup table for high byte.
;
; The table is expected to be 25 chars long, each char represents low byte of the address of GOTOX screen data for this sprite.
;
; X = table address high byte
; A = table address low byte
SpriteSetupGotoXHigh:
	; since this routine may be called after destroying Y register, we need to always restore it
	ldy SPRITE_INDEX
	stx _SpriteGotoXHighH, y
	sta _SpriteGotoXHighL, y
	rts

;-------------------------------------------------------------------------------
; Sets up address of sprite frames data.
;
; X = address high byte
; A = address low byte
SpriteSetupFramesData:
	; since this routine may be called after destroying Y register, we need to always restore it
	ldy SPRITE_INDEX
	stx _SpriteFramesDataH, y
	stx _SpriteFramesDataCurrentH, y
	sta _SpriteFramesDataL, y
	sta _SpriteFramesDataCurrentL, y
	rts

;-------------------------------------------------------------------------------
; Sets up animation for a sprite and resets frame index and duration counter so next time the animation will start from scratch.
;
; Each sprite can have 1 animation "assigned". But of course you're free to change the animation at any point.
;
; A = number of frames
; Y = high byte of animation frame indices lookup table
; X = low byte of animation frame indices lookup table
; Z = duration of each frame
SpriteSetupAnimFrames:
	; make backup of data since we'll need registers for calculations
	pha									; number of frames
	phy									; high byte of animation frames table

	; from hereon, Y will be sprite index
	ldy SPRITE_INDEX					; Y <- current sprite index

	; setup frame duration
	tza									; A <- frame duration
	sta _SpriteAnimFrameDuration, y		; save to duration table
	sta _SpriteAnimFrameDurationCounter, y

	; setup animation table
	pla									; A <- high byte of the table
	sta _SpriteAnimTableH, y			; save high byte address
	stx _SpriteAnimTableL, y			; save low byte address

	; setup frames count
	pla									; A <- frames count
	sta _SpriteAnimFramesCount, y		; save number of frames to our data

	; reset frames index and duration counter
	lda #0
	sta _SpriteAnimCurrentFrame, y

	rts

;===============================================================================
; POSITION
;===============================================================================

;-------------------------------------------------------------------------------
; Sets new X position for selected sprite.
;
; Works with signed values.
;
; Y = position high byte
; X = position low byte
; A = fractional position
SpriteSetX:
	; prepare MSB; the value is $00 if AXY is positive, $ff otherwise
	pha							; we'll need A for checking sign
	tya							; A <- position high bytes
	bmi +						; A < 0?

	ldz #$00					; Z <- 0 when value is positive or 0
	bra ++

+	ldz #$ff					; Z <- $ff when value is negative

++	pla							; A <- fractional position, restored

	stq [SPRITE_POSITION_X]		; save Q to position data
	rts

;-------------------------------------------------------------------------------
; Sets new Y position for selected sprite.
;
; Works with signed values.
;
; X = position
; A = fractional
SpriteSetY:
	; prepare MSW; the value is $0000 if AX is positive, $ffff is negative
	pha							; we'll need A for checking sign
	txa							; A <- position
	bmi +						; A < 0?

	ldz #0						; Z <- 0 when value is positive or 0
	ldy #0						; Y <- 0 when value is positive or 0
	bra ++

	ldz #$ff					; Z <- $ff when value is negative
	ldy #$ff					; Y <- $ff when value is negative

++	pla							; A <- fractional postiion, restored

	stq [SPRITE_POSITION_Y]		; save Q to position data
	rts

;-------------------------------------------------------------------------------
; Adds the given offset to selected sprite X position.
;
; Works with signed values.
;
; Y = offset high byte
; X = offset low byte
; A = fractional offset
SpriteAddX:
	; prepare MSB; the value is $00 if AXY is positive, $ff otherwise
	pha							; we'll need A for checking sign
	tya							; A <- position high bytes
	bmi +						; A < 0?

	ldz #$00					; Z <- 0 when value is positive or 0
	bra ++

+	ldz #$ff					; Z <- $ff when value is negative

++	pla							; A <- fractional position, restored

	clc
	adcq [SPRITE_POSITION_X]	; Q <- Q + current position
	stq [SPRITE_POSITION_X]		; save Q to position data
	rts

;-------------------------------------------------------------------------------
; Adds the given offset to selected sprite Y positon.
;
; Works with signed values.
;
; X = offset position
; A = fractional offset
SpriteAddY:
	; prepare MSW; the value is $0000 if AX is positive, $ffff is negative
	pha							; we'll need A for checking sign
	txa							; A <- position
	bmi +						; A < 0?

	ldz #0						; Z <- 0 when value is positive or 0
	ldy #0						; Y <- 0 when value is positive or 0
	bra ++

+	ldz #$ff					; Z <- $ff when value is negative
	ldy #$ff					; Y <- $ff when value is negative

++	pla							; A <- fractional postiion, restored

	clc
	adcq [SPRITE_POSITION_Y]	; Q <- Q + current position
	stq [SPRITE_POSITION_Y]		; save Q to position data 
	rts

;===============================================================================
; VELOCITY
;===============================================================================

;-------------------------------------------------------------------------------
; Sets X velocity of the selected sprite.
;
; X = "pixel" velocity
; A = fractional velocity
SpriteSetVelocityX:
	; prepare MSW; the value is $0000 if AX is positive, $ffff is negative
	pha							; we'll need A for checking sign
	txa							; A <- position
	bmi +						; A < 0?

	ldz #0						; Z <- 0 when value is positive or 0
	ldy #0						; Y <- 0 when value is positive or 0
	bra ++

+	ldz #$ff					; Z <- $ff when value is negative
	ldy #$ff					; Y <- $ff when value is negative

++	pla							; A <- fractional postiion, restored

	stq [SPRITE_VELOCITY_X]		; save Q to velocity data
	rts
	
;-------------------------------------------------------------------------------
; Sets Y velocity of the selected sprite.
SpriteSetVelocityY:
	; prepare MSW; the value is $0000 if AX is positive, $ffff is negative
	pha							; we'll need A for checking sign
	txa							; A <- position
	bmi +						; A < 0?

	ldz #0						; Z <- 0 when value is positive or 0
	ldy #0						; Y <- 0 when value is positive or 0
	bra ++

+	ldz #$ff					; Z <- $ff when value is negative
	ldy #$ff					; Y <- $ff when value is negative

++	pla							; A <- fractional postiion, restored

	stq [SPRITE_VELOCITY_Y]		; save Q to velocity data
	rts

;-------------------------------------------------------------------------------
; Reverses X velocity of the selected sprite.
SpriteReverseVelocityX:
	; we reverse by performing "0 - velocity"
	lda #0
	tax
	tay
	taz

	sec
	sbcq [SPRITE_VELOCITY_X]
	stq [SPRITE_VELOCITY_X]

	rts

;-------------------------------------------------------------------------------
; Reverses Y velocity of the selected sprite.
SpriteReverseVelocityY:
	; we reverse by performing "0 - velocity"
	lda #0
	tax
	tay
	taz

	sec
	sbcq [SPRITE_VELOCITY_Y]
	stq [SPRITE_VELOCITY_Y]

	rts

;-------------------------------------------------------------------------------
; Applies velocity to position (both X and Y) for selected sprite.
SpriteApplyVelocity:
	clc
	ldz #0
	ldq [SPRITE_POSITION_X]		; Q <- X position
	adcq [SPRITE_VELOCITY_X]	; Q <- Q + X velocity
	stq [SPRITE_POSITION_X]

	clc
	ldz #0
	ldq [SPRITE_POSITION_Y]		; Q <- Y position
	adcq [SPRITE_VELOCITY_Y]	; Q <- Q + Y velocity
	stq [SPRITE_POSITION_Y]

	rts

;===============================================================================
; ANIMATIONS
;===============================================================================

;-------------------------------------------------------------------------------
; Advances the frame for selected sprite, wrapping up to start of the animation table if needed.
;
; This routine only prepares the data, `SpriteApplyRRBPosition` needs to be called afterwards to actually apply it and make changes visible on screen.
;
; This requires prior setup:
; - SpriteSetupFramesData
; - SpriteSetupAnimTable
SpriteAnimAdvanceFrame:
	ldy SPRITE_INDEX					; Y <- current sprite index

	; we only advance animation every Nth frame, based on setup
	lda _SpriteAnimFrameDurationCounter, y
	dec
	sta _SpriteAnimFrameDurationCounter, y
	beq @resetDuration					; if we reached desired frame, advance
	rts									; otherwise exit
	
@resetDuration:
	; reset duration counter
	lda _SpriteAnimFrameDuration, y
	sta _SpriteAnimFrameDurationCounter, y

	; increment frame
	lda _SpriteAnimCurrentFrame, y		; A <- current index
	inc									; A <- A + 1

	; handle wrap over
	cmp _SpriteAnimFramesCount, y		; compare with frames count
	bne @resetAnimation					; we're still below, continue
	lda #0								; we reached over last frame, reset to first

@resetAnimation:
	; store new frame index
	sta _SpriteAnimCurrentFrame, y

	; adjust sprite frame data to point to new frame; we can take advantage of the fact that we either increment or reset to 0
	cmp #0								; are we on frame 0?
	bne @advanceAnimation				; no, increment current data to point to next frame

	; reset pointer to first frame. This code assumes frames are stored in lower 64K of memory!
	lda SPRITE_FRAME_DATA_FIRST
	sta SPRITE_FRAME_DATA
	lda SPRITE_FRAME_DATA_FIRST + 1
	sta SPRITE_FRAME_DATA + 1

	bra @updateData

@advanceAnimation:
	; we need to increment current pointer to next frame. We again use hard coded frame size here to simplify the code AND also assume data is stored in lower 64K of RAM!
	clc
	lda SPRITE_FRAME_DATA
	adc #SPRITE_FRAME_SIZE
	sta SPRITE_FRAME_DATA

	lda SPRITE_FRAME_DATA + 1
	adc #0
	sta SPRITE_FRAME_DATA + 1

@updateData:
	; when we have new frame data, we have to update our data table as well
	lda SPRITE_FRAME_DATA
	sta _SpriteFramesDataCurrentL, y
	lda SPRITE_FRAME_DATA + 1
	sta _SpriteFramesDataCurrentH, y

	rts

;-------------------------------------------------------------------------------
; Manually sets desired animation frame for selected sprite.
;
; This routine only prepares the data, 'SpriteApplyRRBPosition' call needs to be done afterward to actually make changes visible.
;
; This will interfere with `SpriteAnimAdvanceFrame`, use either one or the other! This routine is not very optimal since it will iterate over the frame indexes every time while calculating the offset into frame data.
;
; Requires prior frames data setup through `SpriteSetupFramesData`
;
; X = frame index
SpriteAnimSetFrame:
	; prepare pointer to first frame data
	ldy SPRITE_INDEX
	lda _SpriteFramesDataL, y
	sta SPRITE_FRAME_DATA
	lda _SpriteFramesDataH, y
	sta SPRITE_FRAME_DATA + 1
	
	; if we want first frame, we're done, just apply it
	cpx #0
	beq @apply

	; iterate until we reach our desired frame
@nextFrame:
	; advance frame pointer to next frame
	clc
	lda SPRITE_FRAME_DATA
	adc #SPRITE_FRAME_SIZE
	sta SPRITE_FRAME_DATA

	lda SPRITE_FRAME_DATA + 1
	adc #0
	sta SPRITE_FRAME_DATA + 1

	; loop until we reach our frame
	dex
	bne @nextFrame

@apply:
	; when we have new frame data, we have to update our data table as well
	lda SPRITE_FRAME_DATA
	sta _SpriteFramesDataCurrentL, y
	lda SPRITE_FRAME_DATA + 1
	sta _SpriteFramesDataCurrentH, y

	rts

;===============================================================================
; RASTER REWRITE BUFFER
;===============================================================================

;-------------------------------------------------------------------------------
; Applies data for selected sprite into RRB data
;
; Requires to first setup RRB and frame addresses:
; - SpriteSetupRRB
; - SpriteSetupFrame
;
; NOTE: at the moment this routine places sprites 8px below the actual Y coordinate (1 screen row). It's because it doesn't account for the transparent characters row on top of each frame. Also it probably won't work correctly with negative coordinates. But the main purpose of this code is to verify M65Converter exported data is correctly formatted for Mega 65 hardware. It should be good enough for that ¯\_(ツ)_/¯
SpriteApplyRRBPosition:
	; copy X position to code below using self modifying code
	ldz #0
	ldq [SPRITE_POSITION_X]				; Q <- X position, A = fraction, X = low, Y = high
	stx @sprDataXLo + 1					; save low byte value below where we need it
	sty @sprDataXHi + 1					; save high byte value below where we need it

	; calculate Y offset (bits 2-0 of the Y position)
	ldz #0
	ldq [SPRITE_POSITION_Y]				; Q <- Y position, A = fraction, X = position
	txa									; A <- y position
	and #%00000111						; A <- lower 3 bits only      (%00000YYY)
	eor #%00000111						; A <- bottom 3 bits reversed (%00000yyy)
	asl									; A <- %0000yyy0
	asl									; A <- %000yyy00
	asl									; A <- %00yyy000
	asl									; A <- %0yyy0000
	asl									; A <- %yyy00000
	sta @sprDataYOffs + 1				; store to the loop below (self modifying)

	; determine top character row where we will start drawing the sprite (in other words, this is where we will start incrementing sprite frame rows)
	txa									; A <- y pixel position (%yyyyyyyy)
	lsr									; A <- A / 2
	lsr									; A <- A / 4
	lsr									; A <- A / 8 = character row
	sta SPRITE_DRAW_TOP_ROW 			; store to top row ZP variable

	; we should start applying X/Y GOTOX offset 1 row above sprite to correctly account for Y offset, but only if start row is > 0
	beq +								; if top row == 0, take it as is
	dec									; no, subtract 1 - we want to start drawing top transparent row 1 row above sprite to account for Y offset
+	sta SPRITE_DRAW_GOTOX_ROW

	; determine bottom character row
	clc
	adc #SPRITE_HEIGHT_CHARS			; A <- A + height
	inc									; A <- A + 1 (we increment frame row counter in advance)
	sta SPRITE_DRAW_BOTTOM_ROW			; store to bottom row ZP variable

	; prepare remaining data for the loop
	lda #0								; we'll reset data to 0:
	sta SPRITE_GOTOX_ADDR + 3			; MSB of screen data in ZP is always 0 - all our data is stored in first 384K so we only ever need 3 bytes
	sta SPRITE_DRAW_FRAME_ROW			; we always start drawing the first char of the sprite frame

	; vvvv-------- Y register represents screen row --------vvvv

	ldy #0								; Y = screen character row index

@nextRow:
		; ////////////// LOOKUP ADDRESS PREPARATION

		; prepare the lookup addres in ZP
		lda (SPRITE_GOTOX_LO), y			; A <- LSB byte of lookup address
		sta SPRITE_GOTOX_ADDR
		lda (SPRITE_GOTOX_MID), y			; A <- mid byte of lookup address
		sta SPRITE_GOTOX_ADDR + 1
		lda (SPRITE_GOTOX_HIGH), y			; A <- high byte of lookup address
		sta SPRITE_GOTOX_ADDR + 2

		; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
		; ////////////// DETERMINING DATA TO DRAW IN CURRENT ROW

		; update GOTOX and sprite char addresses of this screen row
		ldz #0								; Z = index into screen memory

		; we should write off-screen GOTOX data for all rows above our sprite (minus 1 which is needed for correctly applying Y offset)
		cpy SPRITE_DRAW_GOTOX_ROW			; are we still above sprite top row - 1?
		bmi .writeOffScreenGotoX			; yes, continue drawing off-screen GOTOX data and top transparent characters

		; below first row in which we should start applying GOTOX offsets, but before we reach the actual top sprite row, we should not increment frame rows, but still render the offsets for GOTOX data
		cpy SPRITE_DRAW_TOP_ROW				; are we still above top row in which we need to start drawing sprite?
		bmi .writeOffsetGotoX				; yes, we can continue drawing top transparent characters, outside of visible screen area to avoid Y offset artifacts

		; once we reach the the bottom sprite frame data row, we stay in it until the end of the screen data (if we'd increment, we'd reach into subsequent frames)
		cpy SPRITE_DRAW_BOTTOM_ROW			; did we reach bottom row from which we need to draw bottom transparent characters?
		bpl .writeOffScreenGotoX			; yes, remain in current sprite frame data row, without any X/Y offset to avoid artifacts

		; we need to increment top sprites row and frame data indexer and use X/Y position on GOTOX data
		clc
		lda SPRITE_DRAW_FRAME_ROW			; A <- current sprite frame index
		adc #SPRITE_WIDTH_BYTES				; A <- A + sprite width
		sta SPRITE_DRAW_FRAME_ROW			; store new start of frame index to variable so we can restore

		; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		; ////////////// DRAWING GOTOX BYTES WITH X/Y OFFSET APPLIED
.writeOffsetGotoX:
		; write byte 0 for GOTOX screen data:
		;
		;  (x position, low byte)
		;  |
		;  +-------
		; %xxxxxxxx
@sprDataXLo:
		lda #$00							; A <- X position, low byte
		sta [SPRITE_GOTOX_ADDR], z			; write to screen data (28-bit memory write)
		inz

		; write byte 1 for GOTOX screen data:
		;
		;  (Y offset 0-7)
		;  |     (X upper 2 bits)
		;  |     |
		;  +--   +-
		; %yyy000xx
@sprDataXHi:
		lda #$00							; A <- X position, high byte
		and #%00000011						; A <- A with all bits cleared but 1-0 (=x hi bottom 2 bits)
@sprDataYOffs:
		ora #$00							; A <- A with added 3 bits of Y offset in bits 7-5
		sta [SPRITE_GOTOX_ADDR], z			; write to screen dta (28-bit memory write)
		inz

		bra .writeChar

		; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		; ////////////// DRAWING GOTOX BYTES WITH OFF-SCREEN COORDINATE ($140 = 320 = just to the right of right screen edge)
.writeOffScreenGotoX:
		lda #$40
		sta [SPRITE_GOTOX_ADDR], z
		inz

		lda #$01
		sta [SPRITE_GOTOX_ADDR], z
		inz

		; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		; ////////////// DRAWING ALL FRAME BYTES
.writeChar:
		; vvvv-------- Y register represents sprite frame index --------vvvv

		sty @restoreScreenRowIndexToY + 1	; copy screen row index to code after we're done with frame data
		ldy SPRITE_DRAW_FRAME_ROW			; X <- current frame data index

		; write all bytes of the current frame data row
		!for i, 0, SPRITE_WIDTH_BYTES - 1 {
			lda (SPRITE_FRAME_DATA), y			; A <- next byte of frame data
			sta [SPRITE_GOTOX_ADDR], z			; write it to screen data (28-bit memory write)
			iny									; increment sprite frame data index
			inz									; increment screen data index
		}

		; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

	; vvvv-------- Y register represents screen row index --------vvvv

	; prepare for next screen row
@restoreScreenRowIndexToY:
	ldy #$00							; Y <- screen row index
	iny									; Y <- Y + 1
	cpy #25								; did we reach last line?
	bne @nextRow						; no, repeat

	rts

;===============================================================================
; DATA
;===============================================================================

SPRITE_DATA_LENGTH = 4		; length of each piece of data (Q = AXYZ = 4 bytes)

_SpritePositionX: !fill SPRITE_COUNT * SPRITE_DATA_LENGTH
_SpritePositionY: !fill SPRITE_COUNT * SPRITE_DATA_LENGTH
_SpriteVelocityX: !fill SPRITE_COUNT * SPRITE_DATA_LENGTH
_SpriteVelocityY: !fill SPRITE_COUNT * SPRITE_DATA_LENGTH

; GOTOX screen pointers
_SpriteGotoXLoL: !fill SPRITE_COUNT
_SpriteGotoXLoH: !fill SPRITE_COUNT
_SpriteGotoXMidL: !fill SPRITE_COUNT
_SpriteGotoXMidH: !fill SPRITE_COUNT
_SpriteGotoXHighL: !fill SPRITE_COUNT
_SpriteGotoXHighH: !fill SPRITE_COUNT

; frames data
_SpriteFramesDataL: !Fill SPRITE_COUNT
_SpriteFramesDataH: !Fill SPRITE_COUNT
_SpriteFramesDataCurrentL: !Fill SPRITE_COUNT
_SpriteFramesDataCurrentH: !Fill SPRITE_COUNT

; animation data - pointer to frame indexes table, number of frames, current frame, frame duration
_SpriteAnimTableL: !fill SPRITE_COUNT
_SpriteAnimTableH: !fill SPRITE_COUNT
_SpriteAnimFramesCount: !fill SPRITE_COUNT
_SpriteAnimCurrentFrame: !fill SPRITE_COUNT
_SpriteAnimFrameDuration: !fill SPRITE_COUNT
_SpriteAnimFrameDurationCounter: !fill SPRITE_COUNT

